name: Windows Archive Extraction Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test-extraction:
    runs-on: windows-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Launch Auto-Unzip (background)
        shell: pwsh
        run: |
          Start-Process -FilePath python -ArgumentList 'auto-unzip.pyw' -WindowStyle Hidden
          Start-Sleep -Seconds 5

      - name: Sequential archive tests (copy -> wait -> verify -> cleanup)
        shell: pwsh
        run: |
          $downloads = Join-Path $Env:USERPROFILE 'Downloads'
          Write-Host "Using simulated Downloads folder: $downloads"

          $tests = @(
            @{ file='test-zip.zip';      type='zip' },
            @{ file='test-7zip.7z';      type='7z'  },
            @{ file='test-rar.rar';      type='rar' },
            @{ file='test-tar.tar';      type='tar' },
            @{ file='test-gzip.gz';      type='gzip'},
            @{ file='test-bz2.bz2';      type='bz2' },
            @{ file='test-cabinet.cab';  type='cab' }
          )

          $failures = 0
          foreach ($t in $tests) {
            $archive = $t.file
            $base = [System.IO.Path]::GetFileNameWithoutExtension($archive)
            # Handle double extension cases (e.g., .tar.gz) by trimming twice when needed
            if ($archive -match '\.tar\.(gz|bz2)$') { $base = $archive -replace '\.(tar\.(gz|bz2))$','-tar' } # simplistic base naming

            Write-Host "--- Testing $archive (expected folder: $base) ---"
            $src = Join-Path 'testing' $archive
            if (-not (Test-Path $src)) { Write-Host "Source $src missing"; $failures++; continue }

            # Pre-clean
            $destFolder = Join-Path $downloads $base
            if (Test-Path (Join-Path $downloads $archive)) { Remove-Item (Join-Path $downloads $archive) -Force -ErrorAction SilentlyContinue }
            if (Test-Path $destFolder) { Remove-Item $destFolder -Recurse -Force -ErrorAction SilentlyContinue }

            Copy-Item $src (Join-Path $downloads $archive)
            Write-Host "Copied archive to Downloads. Waiting for extraction..."
            $maxWait = 30
            $elapsed = 0
            $interval = 2
            $extracted = $false
            while ($elapsed -lt $maxWait) {
              if (Test-Path $destFolder) { $extracted = $true; break }
              Start-Sleep -Seconds $interval
              $elapsed += $interval
            }
            if (-not $extracted) {
              Write-Host "[FAIL] Folder $base not created after $maxWait seconds"; $failures++
              # Cleanup and continue to next archive
              if (Test-Path (Join-Path $downloads $archive)) { Remove-Item (Join-Path $downloads $archive) -Force -ErrorAction SilentlyContinue }
              if (Test-Path $destFolder) { Remove-Item $destFolder -Recurse -Force -ErrorAction SilentlyContinue }
              continue
            }

            # Find ANY .py file inside the extracted tree (more flexible than fixed TESTFILE.py)
            $testFiles = Get-ChildItem -Path $destFolder -Recurse -File -Filter *.py -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName
            if (-not $testFiles) {
              Write-Host "[FAIL] No Python files (*.py) found in $destFolder"; $failures++
              Write-Host "Directory listing for debug:";
              Get-ChildItem -Path $destFolder -Recurse | Select-Object FullName, Length | Format-Table | Out-String | Write-Host
              if (Test-Path (Join-Path $downloads $archive)) { Remove-Item (Join-Path $downloads $archive) -Force -ErrorAction SilentlyContinue }
              if (Test-Path $destFolder) { Remove-Item $destFolder -Recurse -Force -ErrorAction SilentlyContinue }
              continue
            }

            $allGood = $true
            foreach ($tf in $testFiles) {
              Write-Host "Running $tf ..."
              $out = (python $tf).Trim()
              if ($out -ne 'Test Successful!') { Write-Host "[FAIL] Output mismatch from $tf -> '$out'"; $allGood = $false }
            }
            if (-not $allGood) { $failures++ } else { Write-Host "[OK] $archive extracted and script output correct." }

            # Remove archive + extracted folder for isolation
            if (Test-Path (Join-Path $downloads $archive)) { Remove-Item (Join-Path $downloads $archive) -Force -ErrorAction SilentlyContinue }
            if (Test-Path $destFolder) { Remove-Item $destFolder -Recurse -Force -ErrorAction SilentlyContinue }
          }

          if ($failures -gt 0) {
            Write-Error "$failures archive tests failed"; exit 1
          } else {
            Write-Host 'All archive formats passed sequential extraction tests.'
          }

      - name: Post-test diagnostics (always)
        if: always()
        shell: pwsh
        run: |
          Get-Process | Where-Object { $_.ProcessName -like '*python*' } | Select-Object ProcessName,Id | Format-Table

